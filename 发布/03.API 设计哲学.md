# 03 万物皆资源：Kubernetes 声明式 API 的设计哲学

你是否思考过这样一个问题：“当我们执行 `kubectl apply -f my-goal.yaml` 之后，Kubernetes 究竟是如何读懂我们的意图，并精确地满足我们的期望呢？”

这就是我们今天的主角——`Kubernetes API`。它在背后驱动着一切，让“声明式”不再仅仅是一个优雅的理念，而是一个坚固、可靠的工程现实。而这套 API 体系，正是连接用户“期望”（Declarative State）与集群“现实”（Actual State）之间的桥梁。

## 万物皆资源

Kubernetes 是一个设计精妙的分布式系统，经过 10 多年的高速发展，它已经成为了云原生时代**面向分布式集群的、事实上的操作系统**。之所以如此称谓，并非夸张，而是为了强调它在抽象和管理底层异构资源（如计算、网络、存储）方面所扮演的革命性角色，其重要性不亚于单机时代的操作系统变革。如果你手动部署过 Kubernetes 集群（例如通过二进制的方式），你一定能更深刻地感受到它的强大。如果你从未部署过，强烈推荐你看看我的《K8s 二进制部署课》。

声明式系统的实现，依赖 K8s 这个坚实的底座，而 `kube-apiserver` 则是这个底座的唯一入口。所有的集群内部组件（如 Scheduler, Controller Manager）、外部工具（如 kubectl, Prometheus）、以及集群管理员，**都必须且只能**跟 apiserver 对话，**它是整个集群状态访问和变更的唯一网关**。因此，我们文章开头提到的那个 `kubectl` 命令，最终会将 `my-goal.yaml` 承载的“意图”发送到 API 服务器，由 apiserver 组件接收并解析。

现在，我们来思考一个问题：“my-goal.yaml 是我们声明的意图，我们可以随便写吗？” 比如，我们对 apiserver 说：“嘿，帮我运行一个 Web 服务”。像下面这样：

```yaml
name: web-service
```

可以吗？

**绝对不行！** 你立马会收到 APIServer 的拒绝和报错信息，**因为这个“方言”它完全无法理解**。在 Kubernetes 集群中，有一整套**极其严格且标准化的“名词”体系**，例如：Pod、Node、Deployment、Service ... 等，你必须**严格地**使用这些“名词”和它对话，来表达你的意图。

这些“名词”统称为**API 资源对象（Resource Objects）**。只有标准化的资源对象才能被 K8s APIServer 认识、理解、**存储**并**持续管理**。

因此，当我们想运行一个 Web 服务时，第一步就是要选择合适的资源对象，通常来说，Web 服务会作为 Pod 运行在集群中，所以，我们可以这样**精确地**声明意图：

```yaml
# my-goal.yaml
apiVersion: v1
kind: Pod
metadata:
  name: web-service
spec:
  containers:
  - name: web-service-container
    image: nginx
```

当这个**结构化**的内容发给 APIServer，它就认识了。你可能会想：“这里多出来的 apiVersion 和 spec 是什么意思呢？” 不着急，这个问题是理解 K8s API **精髓**的关键，我们稍后再讲。

现在，我们先来理解一下，如何将这个意图（my-goal.yaml）告诉 K8s APIServer？通过什么**通信协议或模式**呢？

答案是 **REST（Representational State Transfer）**。

REST 架构天生就是用来操作各种资源的。当你输入 kubectl ... 命令，按下回车，其背后就是在调用 APIServer 的 RESTful API，例如：`POST /api/v1/namespaces/default/pods` **（这个动作代表‘创建’）**。在我们刚刚编写的 YAML 文件里，第一行的 `apiVersion: v1` 就对应这里的 `/api/v1/...` Path。


## API 分组

现在，是时候来讲讲 `apiVersion` 这个字段**究竟在 K8s 的架构中扮演什么角色**了？

Kubernetes API 并不是简单地以资源对象为单位进行管理，而是以 `group/version` 的方式进行分组管理。所有的分组总体上分为两类：

- **核心组（Core Group）**：这个组里的资源对象都被表示为 `apiVersion: v1`。
- **扩展组 API**：常见的有 `apiVersion: apps/v1`，`apiVersion: metrics.k8s.io/v1beta1` 等。

如果你是初次接触这个概念，大概率你会对 `v1` 感到困惑，因为核心组的 apiVersion **看起来**就是固定的 `v1`，并不以 `group/version` 的方式存在。其实，这是一段非常有趣的 API 演进史，**它完美展现了软件架构设计中“向后兼容”与“未来扩展”的平衡艺术**。

一开始，Kubernetes 刚刚诞生的时候，整个集群只有 Pod，Service，ConfigMap ...等等一些核心的资源对象，它们大都是我们常见的，熟悉的，最常用的，**也是维系集群运转的基础**。因为资源对象比较少，管理也比较简单，所以它们的 REST 访问路径都放在 `/api/v1/...` 下面管理，例如：`/api/v1/namespaces/default/pods` 是 Pod 的**RESTful API 端点（Endpoint）**。

后来，随着 Kubernetes 的快速演进，出现了越来越多的新的资源对象，如“应用部署 (Deployment)”、“有状态集 (StatefulSet)”、“网络策略 (NetworkPolicy)”，**甚至包括后来的自定义资源（CRD）**等等。

那么，随之而来的问题也出现了：**如果把所有的资源对象都堆积在 `/api/v1/` 这一个路径下，那将是一场难以维护和扩展的管理灾难**。

于是，**API 分组 (API Groups)** 诞生了。

首先，最古老、最重要的资源（如 Pod, Service, Node ... 等），为了保持与之前的版本兼容性，它们继续被放在 `/api/v1` 路径下不变。这就是**核心组 API**。

然后，将所有新增的资源对象，重新设计一个统一的路径：`/apis/`（注意，是复数 `apis`，**这在路径上与核心组的 `/api` 形成鲜明对比**），并使用标准化的路径格式（`/apis/<Group>/<Version>/...`）来表示新的 REST 访问路径。这就形成了**扩展组 API**。

一些最常见的扩展组 API 如下：

- **应用类资源 (Apps Group):** 如 Deployment, StatefulSet。它们被放在 `/apis/apps/v1/...`。
- **网络类资源 (Networking Group):** 如 Ingress, NetworkPolicy。它们被放在 `/apis/networking.k8s.io/v1/...`。
- **存储类资源 (Storage Group):** 如 StorageClasses。它们被放在 `/apis/storage.k8s.io/v1/...`。

经过这样地重新设计，重新分组，带来了极大地管理便利，使得 API 不仅可以无限扩展，同时也能通过版本号（如 `v1`，`v1beta1`，`v2alpha1`）实现 API 的**版本化**和平滑升级。

另外，值得一提的是，有了分组和版本的资源对象，在 Kubernetes 中也有了一个唯一标识：`GVR`（group、version、resource）。例如，Deployment GVR 的定义如下：

```go
deployGVR := schema.GroupVersionResource{
    Group:    "apps",
    Version:  "v1",
    Resource: "deployments",
}
```

如果你想查看当前集群中所有的 API Group 和 资源对象列表，可以通过 `kubectl api-resources` 命令实时获取集群中最新的资源信息。

> 无论是**核心组 API**还是**扩展组 API**，它们都是 Kubernetes 内置的资源对象。但更高级的用法，是自定义专属于我们自己项目的资源对象，这就是 CRD。这也是本系列文章中最重要的内容，我们后续的项目实战，为车联网平台设计专属的 `Vehicle` CRD 时，就将创建我们自己的 API Group（例如 `iov.cloupeer.io`），届时，我们再详细讲解。


## API 标准

面对 Kubernetes 集群中各种各样的 API Group 和 资源对象，我们该说什么“语言”与 APIServer 进行沟通呢？

答案是 `YAML`，严格来说，其实是 `JSON`。YAML 只是作为一种**人类可读性更强**的格式存在，`kubectl` 和 APIServer 在通信时，通常会将其转换为 JSON。但对用户而言，YAML 确实是事实上的标准。

为了统一，Kubernetes 制定了 API 沟通的约定，这就是 YAML 文件的标准格式。**下面四个字段是构成一个合法 K8s 资源清单的“四大金刚”，缺一不可。**

- `apiVersion`: 表示这个资源对象属于哪个 Group 的什么版本（例如 `apps/v1`）。
- `kind`: 资源对象的类型（如 `Deployment`）。
- `metadata`: 资源对象的元数据（如 `name: my-app`, `labels: {env: prod}`）。
- `spec`: **你期望的状态**（如：`replicas: 3`）。

以上 4 个字段都是管理员的声明，也就是我们要表达的意图。当 APIServer 收到这个意图，会触发 Controller 的调谐循环，并反馈这个资源的**现实的状态（Actual State）**，并把这个现实的状态回填到 `status` 字段中。*其中，`spec` 是用户的“期望”，`status` 是系统的“反馈”，而 Controller 的工作就是不断地“调谐”（Reconcile），使“现实”无限接近并达到“期望”。*

YAML 统一了所有**资源对象**的“数据结构”。它确保了无论你通过 **REST** 接口提交哪个 **API 分组** 的资源，其格式都是一致的（都有 `apiVersion`, `kind`, `metadata`, `spec`），这极大地降低了学习和使用的复杂度。


## OpenAPI 规范

我们如何知道 APIServer 到底提供了多少种资源呢？在你部署一个 Deployment 应用时，如何知道它的 `spec` 字段里到底能填哪些选项呢？这些选项是 `string` 还是 `int`？哪些是必填的？

所有这些问题都指向了 **OpenAPI 规范**。

OpenAPI 规范从 Swagger 规范演进而来，经过多年的发展，当前主流的版本是 `3.x`。从 Kubernetes v1.27 版本开始，OpenAPI v3 版本已经被稳定支持。你只需要通过 `kube-apiserver` 的 `/openapi/v3` 端点，就能拿到当前 K8s 集群支持的 “API 实时操作手册”，这个手册记录了所有可用的资源列表，以及数据结构。

需要注意的是，OpenAPI 提供的是**机器可读**内容，即 JSON/YAML 文件，**它本身并不适合人类直接阅读和交互**。如果你希望得到人类可读的 UI 页面或者为了调试，你需要使用 `Swagger UI` 或 `Redoc` 这样的生态工具，将这份规范渲染成一份漂亮的、可交互的 API 文档。

你可能会想，我日常使用 `kubectl ...` 命令操作 K8s 的原生资源，已经能够完成大部分工作，似乎也感受不到 OpenAPI 的存在，**它到底有什么用呢？毕竟我的 `kubectl` 已经很好用了。**

你的感受是正确的。如果你仅仅是部署一个无状态应用（Deployment）或者创建一个 Service，查看一下 Pod/Node 健康信息，那确实不需要知道 OpenAPI 的存在。这是因为 `kubectl` 工具和其他生态系统组件已经内置集成了 OpenAPI 的文档，极大地方便了你的使用体验。

然而，理解 OpenAPI 存在的意义，仍然是一个专家级工程师必备的知识。**尤其对于我们 Operator 开发者而言，我们不仅是 OpenAPI 的消费者，更是 OpenAPI 的生产者。** 例如：

1. 当你想要配置一个 Pod 资源的 YAML 文件时，你可以执行 `kubectl explain pod.spec.containers` 命令，这能实时地、精确地告诉你 `containers` 字段里每一个选项的含义、类型和是否必需。

2. 当你执行 `kubectl apply ...` 命令时，如果 YAML 文件里有一个写错的字段（例如把 `containers` 写成了 `container`），APIServer 会立刻拒绝并报错。

3. 当你执行 `kubectl api-resources` 命令时，你可以动态地、实时地看到集群中所有可用的资源，也包括你的 CRD。

4. **客户端库的自动生成 (Client-go Generation)：** Kubernetes 官方的 `client-go` 库，即我们 Operator 用来与 APIServer 交互的 Go 语言 SDK，**它本身就是基于 OpenAPI 规范自动生成的**。规范定义了数据结构（如 `Pod`），工具据此生成了 Go 语言的 `struct`，这才让我们实现了类型安全的编程。

以上所有这些**便捷功能的实现**，其信息的来源就是在**实时地查询并解析** APIServer 发布的 OpenAPI 规范。


## 总结

现在，让我们回过头来，将今天探讨的所有概念串联起来，形成一个完整的闭环。你会发现，Kubernetes API 的强大并非偶然，而是源于一系列精心设计的、环环相扣的架构决策。

我们的探索始于最基本的问题：“**我们要管理什么？**” 答案是集群中的一切状态，而 Kubernetes 将这一切都抽象为了标准化的**资源对象（Resource Objects）**。例如 Pod, Deployment ... 这些“名词”是我们一切期望和意图的载体。

接着是“**我们如何管理这些‘名词’？**” Kubernetes 选择了一条成熟且具备高度互操作性的道路：**RESTful API**。我们使用 `POST`, `GET`, `PUT`, `DELETE` 等“动词”来操作这些“名词”（资源），使得任何语言、任何工具（无论是 `kubectl` 还是我们编写的 Operator）都能以统一的协议与之轻松交互。

随着资源“名词”的急剧增多，“**如何组织它们？**” 成为下一个严峻的挑战。**API 分组 (API Groups)**（如 `apps/v1`）应运而生。它不仅通过 `group/version` 的形式清晰地划分了 API 的命名空间（这直接决定了 REST 的 URL 路径），更带来了至关重要的**版本化能力**，让庞大的 API 体系在不断迭代中得以平滑演进。

有了组织，还需要解决“**如何确保体验的一致性？**” 这就是 **API 标准（或称为 API 约定）** 的巨大价值。Kubernetes 规定，所有资源都必须拥有 `apiVersion`, `kind`, `metadata`, `spec` 这样的标准结构。这种高度的一致性确保了用户和开发者，在学习和使用不同资源时，其心智模型是统一的，这极大地降低了整个生态的学习和使用复杂度。

最后，也是最精妙的一环：“**如何让外界知道这一切规范？**” `kube-apiserver` 并没有选择编写一份静态的、易过时的 Word 文档，而是选择通过 **OpenAPI 规范** 发布了一份动态的、机器可读的“实时手册”。这份规范精确定义了上述所有细节——从可用的 API 分组、资源，到每个资源的 `spec` 字段和数据类型。正是这份“活手册”，使得 `kubectl explain` 的智能提示、`client-go` 的自动生成 和服务端强大的 Schema 校验成为了可能。

**如果用一句话来概括这个精妙的系统：**

Kubernetes API 是一个严格遵循 **OpenAPI 规范** 的 **RESTful** 服务，它通过 **API 分组** 来组织和版本化各种**资源对象**，并要求所有资源都遵循统一的 **API 标准**（`kind`, `spec` 等），最终才得以坚实地撑起了整个集群的声明式管理。

以上这五个环节环环相扣，共同构成了一个逻辑严密、工程精巧、并且可无限扩展的声明式 API 体系。
