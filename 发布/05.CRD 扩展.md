# 05 Operator 开发基石：Kubernetes CRD 核心概念详解

我们前面的文章已经不止一次地提到了 CRD，本文就来详细解读一下。

在 [API 设计哲学](https://mp.weixin.qq.com/s/zJ9jSm1daYGrYovY4CmkXA)那篇文章里，我们提到过：**核心组 API** 和**扩展组 API** 都属于 Kubernetes 的内置资源类型，如：Pod、Service、Deployment、Ingress 等。这些都是我们日常最熟悉的对象类型，它们通用、功能强大且设计精良，然而，对于一些复杂的、特定领域的业务需求，仅仅依靠这些内置的资源类型往往会力不从心。

想象一下，我们正在构建的这个车联网（IoV）平台，“车辆”（Vehicle）才是我们管理的核心对象。我们希望能像管理 `Pod` 一样来管理每一辆车，但问题是：Kubernetes 并不知道什么是“车辆”（Vehicle）、什么是“固件版本”（FirmwareVersion）或者“OTA 升级任务”（OTATask）。

我们如何能用 `kubectl get vehicles` 来查看所有入网的车辆？我们又如何能像更新一个 `Deployment` 那样，通过修改一个 YAML 文件来声明式地“将车辆 `VIN-123` 的固件升级到 `v2.0`”？

答案就是：**扩展 Kubernetes API**。


## 两种扩展方式

Kubernetes 提供了一个强大的机制，允许开发人员在不修改 Kubernetes 源码的情况下，对 API 进行扩展，并且仍然能使用 `kubectl` 和声明式 YAML 这些我们熟悉的语法，来对新增的 API 进行操作。

这正是 `Rancher`、`Prometheus Operator`、`Istio` 等众多云原生项目构建其复杂功能的核心所在。

目前，要实现 Kubernetes API 的扩展，有两种方式：

1. **CRD（Custom Resource Definition）**：这是目前最常用、最主流的方式。你只需要定义你的资源“长什么样”（Schema），Kubernetes 就会自动为你处理 API 服务和存储。

2. **API 聚合（Aggregation）**：这是一种更重量级的方式。你需要自己编写一个独立的 API Server，然后“聚合”到 `kube-apiserver` 上。

在本文中，我们只关注第一种方式——**CRD（自定义资源定义）**，它也是我们车联网项目实现 Vehicle 资源的核心方式。我们将详细解读它的概念、如何定义，以及它与 Operator 控制器（Controller）之间至关重要的关系。


## 核心概念

**CRD** 和 **CR** 是初学者最容易混淆的两个概念，我们必须先厘清这两个概念之间的区别和联系。

CRD 的英文全称是 **Custom Resource Definition**，翻译过来就是**自定义资源定义**。顾名思义，CRD 是一种资源的定义，是“模板”，是“图纸”，是元数据。你可以把它理解为数据库（例如 MySQL）中的 `CREATE TABLE` 语句，当你创建一个 Vehicle CRD 时，其实就是在告诉 Kubernetes：“嘿，K8s，请你现在认识一种新的资源类型，我们称之为 `Vehicle`，它应该有这些字段（如 `spec` 和 `status`），它的复数形式叫 `vehicles`，缩写叫 `vh`。” 

当 Kubernetes（更精确的说法是 `kube-apiserver`）收到你这个 CRD 时，它会说：“好的，我明白了。我现在知道怎么处理 Vehicle 这种新数据了。” 然后，它会动态地执行这个 `CREATE TABLE` 语句，创建一个新的 API 端点（如 `/apis/iov.domain.io/...`），这个端点就像是数据库中那张新创建的、空空如也的表。

CR 的英文全称是 **Custom Resource**，只看名字就知道，CR 是 CRD 的**实例**。如果说 CRD 是 `CREATE TABLE vehicles (...)` 语句，那么 CR 就是 `INSERT INTO vehicles (...) VALUES (...)` 这条语句所创建的**一行数据**。

在我们的云原生车联网（IoV）平台项目中，Vehicle CRD 只需要在集群中安装一次。而它所对应的 CR 却不一样，每当一辆新车注册时，我们都会在 Kubernetes 集群中创建一个新的 Vehicle CR。如果我们有 100 万辆车，我们就会有 100 万个 `Vehicle` CR 实例。

**总结一下：** 你先向 Kubernetes **提交一个 CRD**，Kubernetes 的 API Server 就会动态地为你生成一套 RESTful API 端点（Endpoints）。从这一刻起，你就可以像操作 `Pod` 一样，通过 `kubectl` 或客户端库（如 client-go）来 `create`, `get`, `list`, `delete` 你的**CR**了。


## CRD 与 Controller

现在我们知道了，安装一个 CRD 可以让 Kubernetes 认识 Vehicle 这种新资源，你也能创建其对应的 Vehicle CR 了。 

但一个重要的问题是：当一个用户创建了一个 `Vehicle` CR，仅仅“认识”它是不够的，**谁来做事呢？**

例如，当我创建一个 `Vehicle` CR，并将其 `spec.firmwareVersion`（*期望状态*）设置为 "v2.0" 时，谁来负责检查车辆的*实际状态*（`status.firmwareVersion`）是否是 "v1.0"，然后去调用 OTA 升级服务，最后再把 `status` 更新为 "v2.0" 呢？

**答案是：Controller (控制器)。**

这就是 CRD 与 Controller 之间密不可分的关系，也是 **Operator** 的核心：

1.  **CRD（数据模型）**：定义了 `Vehicle` 资源，它有 `spec`（期望状态）和 `status`（实际状态）两个部分。
2.  **Controller（业务逻辑）**：这是一个持续运行的程序，它在我们的车联网项目中，就是 `controller-manager` 组件，它会执行一个**调谐循环**。
3.  **调谐循环（Reconciliation Loop）**：控制器会“订阅”（Watch）所有 `Vehicle` 资源的变化，一旦有 `Vehicle` CR 被创建或更新，调谐循环就会被触发。控制器获取到这个 CR，对比它的 `spec` 和 `status`，当有差异（不相等）时，就执行一些业务逻辑来缩小这个差距，当无差异（相等）时，就什么也不做，等待下一次变化。

*CRD 提供了“声明式”的 API 接口（名词），而 Controller 则提供了实现这些声明的“自动化”业务逻辑（动词）。两者结合，就构成了 Operator 模式。*

于是，我们可以得出结论：**Operator = CRD + Controller**。


## CRD 的 YAML 定义

一个标准的 CRD 的 YAML 定义会是什么样的呢？它和 Kubernetes 内置的资源定义一样，也遵循着标准的 YAML 文件定义，有 `apiVersion`，`kind`，`metadata`，`spec` 这些字段。

```yaml
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  # 这个名称的格式必须是: <CRD 的复数名称>.<group>
  name: vehicles.iov.domain.io
spec:
  # group 是我们自定义的，通常使用域名保持唯一性
  group: iov.domain.io

  # CRD 的种类，名称复数，名称单数，简称
  # 这允许我们执行 `kubectl get vehicles/vehicle/vh` 这样的命令
  names:
    kind: Vehicle
    plural: vehicles
    singular: vehicle
    shortNames:
    - vh

  # Scope 定义了这个资源是 命名空间资源 还是 集群资源
  scope: Namespaced

  # CRD 可以定义多个版本
  versions:
    - name: v1alpha1
      # 'served' 是否启用
      served: true
      # 'storage' 是否存储在 etcd 中，只能有一个版本被设置为 true
      storage: true

      # 这是构建健壮 Operator 的关键：启用 /status 子资源（下文详细解释）
      subresources:
        status: {} # 声明一个空的 status 子资源

      # 这里就是遵循了 OpenAPI v3 标准的 Schema 的定义了
      schema:
        openAPIV3Schema:
          type: object
          properties:
            # 这里的 spec 就是 期望状态 字段信息
            spec:
              type: object
              properties:
                firmwareVersion:
                  type: string
                  description: The desired firmware version for this vehicle.
            # 这里的 status 就是 实际状态 字段信息
            status:
              type: object
              properties:
                phase:
                  type: string
                lastSeenTime:
                  type: string
                  format: date-time
```

### 关键字段剖析

1. `group`：设置 API 所属的组，会被映射为 `/apis/` 的下一级目录，这里是 `/apis/iov.domain.io`。强烈推荐使用**域名**，保持唯一性，避免命名冲突。

2. `names`：定义了 `kind`（Vehicle）、`plural`（vehicles）等。这让 Kubernetes 知道如何称呼你的资源，并允许 `kubectl` 通过多种名称（`kubectl get vehicles`、`kubectl get vh`）来查询它。

3. `scope`：设置 API 的生效范围，有两个可选项：`Namespaced` 和 `Cluster`。前者意味着 `Vehicle` CR 必须存在于一个命名空间中。后者意味着在集群范围内全局生效，不局限于任何命名空间（例如 Node、ClusterRole 等）。默认值是 `Namespaced`。

4. `versions`：设置此 CRD 支持的版本，可以设置多个版本。这允许我们的 API 随着时间演进。我们可以从 `v1alpha1` 开始，未来再添加 `v1beta1` 或 `v1`，并提供版本间的转换（conversion）。

5. `subresources`：**（重点）** 这是一个至关重要的设置。启用它（即使只是一个空对象 `{}`），`kube-apiserver` 就会为该资源额外暴露一个 `/status` 子路径。这允许 Controller（控制器）只更新 `status` 字段，而不会意外覆盖用户（或其它系统）设置的 `spec` 字段。这是实现健壮的声明式 API 的最佳实践。

6. `schema.openAPIV3Schema`：这是 CRD 的核心。它使用 OpenAPI v3 规范定义了 `spec` 和 `status` 中每个字段的**数据类型**、**描述**和**约束**（validation）。这就是为什么当你在 `Vehicle` CR 的 `firmwareVersion` 字段中写入一个数字（而不是字符串）时，`kubectl apply` 会立即拒绝你的请求——因为这个模式（schema）起到了校验作用。


## CR 实例

基于 CRD 的定义，我们就可以像创建 Pod 那样，创建 Vehicle CR 的对象实例了。

例如，我们可以创建一个 `vehicle-001.yaml` 文件，在其中定义一个类型为 Vehicle 的 CR 资源对象：

```yaml
apiVersion: iov.domain.io/v1alpha1
kind: Vehicle
metadata:
  name: vehicle-001
  namespace: default # 因为 scope 是 Namespaced，所以最好明确指定
spec:
  firmwareVersion: v2.0
```

执行 `kubectl create` 命令就可以完成这个 CR 的创建：

```bash
kubectl create -f vehicle-001.yaml
# 预期输出：
# vehicles.iov.domain.io/vehicle-001 created
```

此时，你就可以像操作 `Pod` 那样去操作这个 `Vehicle` CR 资源对象了。例如：

```bash
# 查看 Vehicle CRD 下面的所有的 CR 资源对象
kubectl get vehicles.iov.domain.io
# 预期输出：
# NAME           AGE
# vehicle-001    30s

# 可以用 shortName
kubectl get vh vehicle-001 -o yaml
# 预期输出 (注意，status 字段目前为空，等待 Controller 填充)：
# apiVersion: iov.domain.io/v1alpha1
# kind: Vehicle
# metadata:
#   name: vehicle-001
#   namespace: default
#   ...
# spec:
#   firmwareVersion: v2.0
# status: {}

# 删除刚刚创建的 vehicle-001 CR 资源对象
kubectl delete vehicles.iov.domain.io vehicle-001
# 预期输出：
# vehicle.iov.domain.io "vehicle-001" deleted
```


## 总结

CRD 是我们作为平台构建者，将特定领域的“名词”（如 “车辆”）引入 Kubernetes 生态的钥匙。

  * **CRD** 是蓝图（`CREATE TABLE`）。
  * **CR** 是实例（`INSERT` 的数据行）。
  * **Controller** 是实现了**调谐循环**的大脑，它负责读取 CR 的 `spec`（期望），操作现实世界，然后更新 CR 的 `status`（现实）。

现在我们已经深入理解了 CRD 这个“数据模型”和“API 契约”。CRD 负责定义资源的“期望状态”（spec），而 Controller 则通过调谐循环来读取它、操作现实世界，并最终将“实际状态”（status）写回，形成一个完整的自动化闭环。
